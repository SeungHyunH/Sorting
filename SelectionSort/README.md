## **선택정렬(Selection Sort)**

1.  Input에서 정렬할 한 원소를 선택을 합니다. 이를 element라고 하겠습니다.
2.  element의 다음원소부터 리스트 끝까지 검사를 해서 가장 적은값을 선택해 위치를 바꿉니다.
    -   이 때 주의할 점은 element를 포함해서 가장 적은값을 선택해야 하는 것입니다. 따라서 검사할 때 최소값을 element로 초기화 시켜서 검사해야합니다.
3.  1번부터 2번을 가장 왼쪽부터 리스트의 마지막의 바로 전의 원소까지 반복합니다. 즉 마지막 원소를 제외한 모든 리스트를 검사를 하는겁니다.

-   (N-1)+(N-2)+ ... + 1 = N\*(N-1)/2 = O(n^2) → 시간복잡도 : O(n^2)
-   장점 : 구현이 쉽다.
-   단점 : 안정성(stability)을 만족하지 않고, 계산횟수가 많다.

＊안정성이란? - 정렬을 했을 때 레코드의 상대적인 위치가 바뀌지 않는 것

-   3,3,2,1 을 선택정렬하면 1,2,3,3 이 됩니다. 이 때 3은 똑같은 값이니까 별로 상관없지 않나? 라고 생각할 수 있습니다. 이 때 3을 다르게 표현해보죠. a,b,2,1 이런식으로 변수에 저장된 값이라고 생각을 해봅시다.(아니면 파일이라고 생각해보죠 저장된 위치가 다르겠죠?) 이 것을 선택정렬을 한다면 1,2,b,a 로 정렬이 됩니다. 정렬전에는 a가 b보다 앞에 있는 index였지만 정렬 후에는 a가 b보다 뒤에 있게 됩니다. 이를 "안정성을 만족하지 않는다"라고 합니다.
